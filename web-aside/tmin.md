## Notice

The material in this document is supplementary material to the book Computer Systems, A Programmer’s
Perspective, Third Edition, by Randal E. Bryant and David R. O’Hallaron, published by Prentice-Hall and
copyrighted 2016. In this document, all references beginning with “CS:APP3e ” are to this book. More
information about the book is available at csapp.cs.cmu.edu.

This document is being made available to the public, subject to copyright provisions. You are free to copy
and distribute it, but you must give attribution for any use of this material.


Copyright © 2015, R. E. Bryant, D. R. O’Hallaron. All rights reserved.

## 1.情况
---

我们小心地编写了`TMin32`的值`-2147483647-1`。为什么不干脆写成`-2147483648`或`0x80000000`呢？查看C头文件`limits.h`，我们发现它们使用的方法与编写`TMin32`和`TMax32`的方法相似：

```c
/* Minimum and maximum values a 'signed int' can hold. */

#define INT_MAX 2147483647

#define INT_MIN (-INT_MAX - 1)
```

不幸的是，二者补码表示的不对称性和C的转换规则之间的一种奇怪的相互作用迫使我们以这种不寻常的方式来编写`TMin32`。尽管理解这个问题需要我们深入研究C语言标准中的一个较模糊的角落，但它将帮助我们理解整型数据类型和表示的一些微妙之处。

考虑将`TMin32`编写为`-2147483648`并编译为32位程序的情况。当编译器遇到一个`-X`形式的数，它首先确定`X`的数据类型和值，然后取反。值`2147483648`太大，无法表示为`int`，因为这个值比`TMax32`大1（不对称性导致！）。编译器尝试确定一种可以正确表示此值的数据类型。根据语言版本的不同，它将向下查找图1中显示的十进制数据类型。对于ISO C90，它会从`int`到`long`再到`unsigned`，然后找到一个可以表示数字`2147483648`的数据类型。值`2147483648`和`−2147483648`在32位机上具有相同的位表示，因此得到的常量具有数据类型`unsigned`和值`2147483648`。对于ISO C99，编译器从`int`到`long`再到`long long`，最后找到一个可以表示数字`2147483648`的数据类型。对于64位，我们可以唯一地表示`2147483648`和`−2147483648`，因此结果常量的数据类型为`long long`，值为`-2147483648`。

| C90十进制     | C90十六进制   | C99十进制 | C99十六进制        |
|:--------------|:--------------|:----------|:-------------------|
| int           | int           | int       | int                |
| long          | unsigned      | long      | unsigned           |
| unsigned      | long          | long long | long               |
| unsigned long | unsigned long |           | unsigned long      |
|               |               |           | long long          |
|               |               |           | unsigned long long |

图1：**表示整数常量的数据类型**。根据语言版本和格式（十进制或十六进制），常量的数据类型由相应列表中可以表示值的第一种类型给出。

在32位程序中编译十六进制常量`0x80000000`时，编译器以类似的方式进行，遵循图1中十六进制情况的列表之一。对于这两种语言版本，它首先将数字与`TMax32`（`0x7FFFFFFF`）进行比较，由于它较大，因此决定该值不能表示为`int`。然后将数字与`UMax32`（`0xffffff`）进行比较，由于它较小，因此选择表示为`unsigned`。因此，它将生成一个数据类型为`unsigned`、值为`0x80000000`（或者等价的`2147483648`）的常量。

64位程序的工作方式有点不同。对于这两种语言版本，十进制形式产生一个数据类型为`long`（64位）且值为`−2147483648`的常量，而十六进制形式产生一个类型为`unsigned`且值为`0x80000000`（或者等价的`2147483648`）的常量。

所有这些变化都可以通过图2所示的表格进行总结。对于结果类型为`long`或`long long`的情况，常量为负，但长度为64位。对于结果类型为`unsigned`的情况，常量为正数，长度为32位。

| 字长   | C90         | C90        | C99         | C99        |
|:------|:------------|:-----------|:------------|:-----------|
| 表达式 | -2147483648 | 0x80000000 | -2147483648 | 0x80000000 |
| 32位   | unsigned    | unsigned   | long long   | unsigned   |
| 64位   | long        | unsigned   | long        | unsigned   |


图2:`TMin32`的**常量表达式产生的数据类型**。根据语言版本和格式（十进制或十六进制），我们可以为这两个表达式获得三种不同的数据类型，包括值为正数的情况。

这些结果可以通过以下代码来证明：

```c
int dpos32 = (-2147483648 > 0);
int hpos32 = (0x80000000 > 0);
```

这些代码行试图将`TMin32`表示为十进制或十六进制常量，并测试该值是否大于零。根据编译器版本和字长，我们发现`dpos32`的值可以是1或0，表示十进制常数可以是正的或非负的，而`hpos32`的值始终是1，表示十六进制常数始终是正的。我们将`TMin32`作为一个常量来编写这项看似简单的任务比预期的要困难得多！

### 练习题1：

考虑以下代码：

```c
int dtmin32 = -2147483648;
int dpos32a = (dtmin32 > 0);
int htmin32 = 0x80000000;
int hpos32a = (htmin32 > 0);
```

我们在一台使用整数补码表示的机器上将此代码编译为32位和64位程序，并在语言标准ISO-C90和ISO-C99中进行了尝试。在所有情况下，我们始终得到`dpos32a`和`hpos32a`的值0，并且进一步的测试验证`dtmin32`和`htmin32`确实等于`TMin32`。解释为什么这段代码没有我们在前面的代码示例中看到的编译器和语言敏感性。

## 2. 启示

对于许多程序，不同字长和语言标准引起的歧义不会影响程序行为（例如，见问题1）。尽管如此，我们现在可以理解为什么将`TMin32`写成`-2147483647-1`的约定会产生更理想的结果。因为`2147483647`是`TMax32`的值，所以它可以表示为`int`，因此不需要调用图1的转换规则。

### 练习题2：

假设我们尝试将`TMin32`写为`-0x7FFFFFFF-1`。C编译器会为32位和64位程序以及C语言标准的两个版本生成`int`类型的常量吗？解释一下。

### 练习题3：

您希望为`TMin_w`编写一个简洁的表达式，其中`w`是数据类型`long int`中的位数。由于此数据类型的大小取决于计算机和编译器设置，因此您决定使用`sizeof`操作，所以只要`w`是`8`的倍数，表达式就会产生`TMin_w`。您还使用了一个技巧，将数字左移3等于将其乘以8。
您第一次尝试此代码是：

```c
/* WARNING: This code is buggy */
/* Shift 1 over by 8*sizeof(long) - 1 */
1L << sizeof(long)<<3 - 1
```

将代码编译为32位程序，发现表达式的计算结果为64。
A. 解释为什么会这样。
B. 对于64位程序，表达式将产生什么值？
C. 对表达式进行最小的修改，以使其正确计算。

### 练习题4：

假设我们尝试将`TMin64`的值写为十进制和十六进制常量。使用图1所示的规则填写下表，以确定结果值应该是什么类型。您可能会发现某些情况下，规则没有为常量定义有效的表示形式，用“undefined”表示此类情况

| 字长 | c版本 | -9223372036854775808 | 0x8000000000000000 |
|:-----|:------|:---------------------|:-------------------|
| 32   | C90   |                      |                    |
| 32   | C99   |                      |                    |
| 64   | C90   |                      |                    |
| 64   | C99   |                      |                    |


## 练习题答案

### 问题1解决方案：

在对整型变量`dtmin32`和`htmin32`赋值时，我们隐式地将值强制转换为32位补码整数。这将产生值`−2147483648`，而不管常量值是有符号的还是无符号的，或者是32位还是64位。

### 问题2解决方案：

是的，不管字长大小和语言标准如何，这都能像预期的那样工作。由于`0x7FFFFFFF`等于`TMax32`，它将用`int`数据类型表示该值。因此，结果表达式的数据类型为`int`。

### 问题3解决方案：

这是一个未考虑C中运算符优先规则的典型示例。加法和减法的优先级高于移位，并且移位关联到左边。

A. 考虑数据类型`long`需要4个字节的情况。然后表达式等价于`1 << 4 << 3 - 1`，其计算结果为`(1 << 4) << 2`，得到64

B. 当`long`需要8个字节时，我们将有`1 << 8 << 3 - 1`，其计算结果为`(1 << 8) << 2`，产生1024。

C. 只需一组括号即可解决此问题：

```c
/* Shift 1 over by 8*sizeof(long) - 1 */
1L << (sizeof(long)<<3) - 1
```

### 问题4解决方案：

这个问题揭示了图1所示规则的一些奇怪方面：

| 字长 | C版本 | -9223372036854775808 | 0x8000000000000000 |
|:-----|:------|:---------------------|:-------------------|
| 32   | C90   | undefined            | undefined          |
| 32   | C99   | undefined            | unsigned long long |
| 64   | C90   | unsigned long        | unsigned long      |
| 64   | C99   | undefined            | unsigned long      |


以下是对这些条目的解释：

**32 / C90**: C90中的任何数据类型都不能表示`TMin64`，因此十进制和十六进制表达式都不能产生有效的常量。

**32 / C99**: 十进制值`9223372036854775808`不能用任何数据类型表示，包括`long long`，因此这也不会产生有效的常量。另一方面，十六进制值`0x80000000000000`可以用数据类型`unsigned long long`表示。

**64 / C90**: 十进制值`9223372036854775808`和十六进制值`0x80000000000000`都可以表示为`unsigned long`。

**64 / C99**: 十进制值`9223372036854775808`不能用任何数据类型表示，因此这也不会产生有效的常量。另一方面，十六进制值`0x80000000000000`可以用数据类型`unsigned long`表示。
